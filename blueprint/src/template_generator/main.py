"""
References:
    blueprint/resources/widgets_template
"""
from os import mkdir
from os import path as xpath

from lk_logger import lk
from lk_utils import dumps
from lk_utils import loads
from lk_utils.filesniff import get_filename

from blueprint.src import io
from blueprint.src.typehint import *


def main(widgets_dir=io.widgets_dir):
    """
    Input:
        io.json_4 (this is generated by `..qml_modules_indexing.no4_all_pyml
        _widgets`.)
        io.text_1, io.text_2, io.text_3.
    
    Output:
        `declare_qtquick.widgets.api.*`
    """
    data_r = loads(io.json_4)  # type: TDataNo6
    
    # data_r 的数据结构比较复杂. 下面的代码逻辑主要基于 `io.json_4.<data>.<key
    # :qtquick>` 进行观察和编写.
    
    _create_dirs(widgets_dir, data_r.keys())

    for package, v0 in data_r.items():
        dirpath = f'{widgets_dir}/{package.replace(".", "/")}'
        
    # --------------------------------------------------------------------------

    template: str = loads('../../resources/widgets_template/template.txt')
    #   template keywords see `../resources/template.txt:docs:placeholders`
    
    # TODO
    
    for package, v1 in data_r.items():
        package = package.lower().removeprefix('qtquick').replace('.', '/')
        #   'QtQuick.Controls' -> 'qtquick.controls' -> '/controls'
        
        for k2, v2 in v1.items():
            imports = _relative_imports(
                target_path=''
            )
            #   note: this is not relative import, we may consider changing it
            #   to relatives, but it needs much more efforts and it is also not
            #   a good proposal though
            widget_name = k2
            parent_name = v2['parent'] or 'Component'
            props_type_hint = _init_props(v2['props'], data_r)
            props_init = _init_props(v2['props'], data_r)
            
            dumps(template.format(
                IMPORTS=imports,
                WIDGET_NAME=widget_name,
                PARENT_NAME=parent_name,
                PROPS_TYPE_HINT='\n    '.join(
                    f'{p}: {t}' for (p, t) in props_type_hint
                ),
                PROPS_INIT='\n    '
            ), f'../../tests/widgets/{package}.py')


def _create_dirs(widgets_dir, packages):
    dirs_ = []
    
    for pkg in packages:
        d = f'{widgets_dir}/{pkg.replace(".", "/")}'
        dirs_.append(d)
    
    dirs_.sort()
    
    with lk.counting(len(dirs_)):
        for d in dirs_:
            lk.logx(xpath.relpath(d, widgets_dir))
            if not xpath.exists(d):
                mkdir(d)


def _relative_imports(target_path: str, parent_path: str,
                      parent_class_name: str) -> Tuple[str, ...]:
    """
    
    Demonstration:
        |= declare_qml  : this is package dir of `declare_qml`
            |= widgets  : all auto generated widgets will be dumped here
                |- item.py      : e.g. `parent_path='/item.py'`
                |= windows      : the widgets directory is multi-layered
                    |- window.py: e.g. `target_path='/windows/window.py'`
    
    Notes:
        relative imports start from `declare_qml` dir, target to `declare_qml/
        widgets/[subdirs]/{py_file}`.
        for example:
            |= declare_qml
                |- typehint.py
                |= widgets
                    |- item.py ::
                    |       from ..core import BaseComponent
                    |       from ..typehint import *
                    |       #    ^^ this is what we need to provide
                    |       class Item(BaseComponent):
                    |           ...
                    |= windows
                        |- window.py ::
                        |       from ..item import Item
                        |            ^^^^^^        ^^^^
                        |       from ...typehint import *
                        |       #    ^^^
                        |       class Window(Item):
                        |           ...
        according to the example, the param `level` minimium value should match
        to '..'
        
    Returns:
        eg (
            'from ..typehint import *',
            'from ..item import Item',
        )
    """
    # relative to `declare_qml`
    reldots1 = '.' * (target_path.count('/') + 1)
    # relative to `parent_path`
    reldots2 = '.' * (target_path.count('/') - parent_path.count('/'))
    assert reldots1 and reldots2
    
    if parent_class_name == '':
        return (
            'from {}.core import BaseComponent'.format(reldots1),
            'from {}.typehint import *'.format(reldots1),
        )
    else:
        return (
            'from {}.typehint import *'.format(reldots1),
            'from {}.{} import {}'.format(
                reldots2, get_filename(parent_path, False), parent_class_name
            ),
        )


def create_package_dirs(file='../resources/no6_all_pyml_widgets.json'):
    data = loads(file)  # type: TDataNo6
    
    home_dir = xpath.abspath('../../tests/widgets')  # A (test)
    # home_dir = abspath('../../declare_qml/widgets')  # B
    assert xpath.exists(home_dir)
    
    dirs_cache = set()
    
    for package in data:
        lk.logax(package)  # eg 'QtQuick.Controls'
        
        _dir = home_dir
        for d in package.split('.'):  # eg ['QtQuick', 'Controls']
            _dir += '/' + d
            if _dir not in dirs_cache:
                # this would be faster than `os.path.exists(_dir)`
                dirs_cache.add(_dir)
                mkdir(d)
    
    del dirs_cache


def _init_props(props: Dict[str, str], data: TDataNo6):
    """
    在 `props` 参数中, 我们会遇到以下情况的属性类型:
        基础的类型: 例如 int, bool, string 等
        js 常见类型: 例如 Array, Object
            此外, Qt 也会用 list 代替 Array 表示 (在 Qt 文当值, 二者应该是混用
            的, 并不是很规范)
        qt 特有的类型: 例如 color, point, font, matrix4x4 等. 它们属于 'QML
            Basic Type'
        嵌套类型: 例如 Array<string>, list<Animation>
        同一包下的其他组件: 例如 AbstractBarSeries 的 axisX 属性的类型是
            'AbstractAxis', 这个 'AbstractAxis' 指的就是与 AbstractBarSeries 同
            属于一个包下的另一个组件
        不同包下的其他组件: 例如 TODO
        级联属性: 有两种格式:
            1. 以点号连接. 例如 `AbstractAxis3D.AxisOrientation`. 表示枚举值
                示例:
                    `AbstractAxis3D.AxisOrientation`:
                        Constant                                Value
                        ---------------------------------------------
                        QAbstract3DAxis::AxisOrientationNone    0x0
                        QAbstract3DAxis::AxisOrientationX       0x1
                        QAbstract3DAxis::AxisOrientationY       0x2
                        QAbstract3DAxis::AxisOrientationZ       0x4
                    `QAbstract3DSeries.Mesh`
                        Constant                                Value
                        ---------------------------------------------
                        QAbstract3DSeries::MeshUserDefined      0x0
                        QAbstract3DSeries::MeshBar              0x1
                        QAbstract3DSeries::MeshCube             0x2
                        QAbstract3DSeries::MeshPyramid          0x3
                        QAbstract3DSeries::MeshCone             0x4
                        QAbstract3DSeries::MeshCylinder         0x5
                        ...                                     ...
            2. 以双冒号连接. 例如 `QtQuick3D::Material`. 可能表示某个组件, 也可
                能表示枚举值.
                表示组件的情况:
                    例如 `QtQuick3D::Material` 表示 QtQuick3D 模块下的 Material
                    组件.
                表示枚举值的情况:
                    例如 `Qt::CursorShape`:
                        Constant            Value
                        -------------------------
                        Qt.ArrowCursor      ?
                        Qt.UpArrowCursor    ?
                        Qt.CrossCursor      ?
                        Qt.WaitCursor       ?
                        ...                 ...
        特殊的类型:
            keysequence, 来源于 `enum QKeySequence::StandardKey`, 我们需要预先写
                好这个 enumeration 类.
            QObject*: 来源于 `QtQuick.Item.containmentMask` 属性
            ...
    
    References:
        There're listed all types in `blueprint.template_generator.sidework
        .static_qml_basic_types()`
    """
    
    def recognize_plain_type(t: str):
        if t in ('array', 'list', 'Array'):
            return 'list'
        elif t in ('bool',):
            return 'bool'
        elif t in ('double', 'float', 'real'):
            return 'float'
        elif t in ('enum', 'enumeration', 'int'):
            return 'int'
        elif t in ('group',):
            # from pyml.properties.property_control import GPropertyControl
            return 'GPropertyControl'
        elif t in ('point',):
            return 'TPoint'
        elif t in ('string', 'url'):
            return 'str'
        elif t in ('stringlist', 'list<string>'):
            return 'list[str]'
        elif t in ('var', 'variant'):
            return '...'
    
    recog = recognize_plain_type
    known_widgets = set()
    for package, v1 in data.items():
        for widget in v1.keys():
            known_widgets.add(f'{package}.{widget}')
    
    for p, t in props.items():  # p: 'property'; t: 'type'
        if '<' in t and t.endswith('>'):
            #   e.g. 'list<string>'
            try:
                assert t.count('<') == 1
                a = t.split('<')[0]
                b = t.replace(a, '').strip('<>')
                yield p, f'{recog(a)}[{recog(b)}]'
            except AssertionError:
                assert t == 'list<list<point>>'
                yield p, f'list[list[TPoint]]'
        else:
            yield p, recog(t)
