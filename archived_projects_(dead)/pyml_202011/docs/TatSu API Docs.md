# Expressions

## `# comment`

表示注释. 注释以井号开头, 注释中的内容不会被处理, 用法和 Python 一样.

## `e`

表达式 (expression). 表达式是一个已定义的变量名称或者一个正则表达式, 例如:

```
/\d+/  # 注意, 正则表达式需要用两个斜杠 "包裹".
```

```
username = /\w+/  # 此时的 username 变量就是我们在说的 `e`.
password = /[-_0-9a-zA-Z]+/
new_user = username ':' password
#          ^-------------------^ 同样是一个表达式, 并在后续可用 new_user 来表示.
```

## `e1 | e2 | e3 | ...`

选择支. 每个 `e` 是一个选项. 此外, 为了形式美观, 在第一个选项前也可以加竖线. 

通常, 我们把它写成换行的形式 (这样更易读且美观), 如下面这样:

```
# 1. 单行形式
# choices = e1 | e2 | e3 | ... ;

# 2. 换行形式
choices
    =
    | e1
    | e2
    | e3
    | ...
    ;
```

## `e1 e2`

顺序匹配. 先匹配 e1, 再匹配 e2, 都满足则匹配成功.

## `( e )`

捕获组. 在括号中的 e 可以是一个匹配目标或选择支, 后者例如:

`( e1 | e2 | e3 | ... )` 

注意第一个选项前面没有竖线.

## `[ e ]`

可选匹配.

## `{ e }` or `{ e }*` or `{ e }+`

闭包. 花括号是一个闭包结构, 星号表示匹配零次或 N 次 (类似正则表达式中的星号的概念), 加号表示匹配一次或 N 次 (类似正则表达式中的加号的概念).

注意, 闭包语句的返回值是一个列表. `{ e }` 返回的是单元素列表, `{ e }*` 返回的是空列表或 N 元素列表.

## `{}`

空的闭包. 匹配到空并返回空列表.

## `~`

截断符号. 它的含义是, 如果一个表达式中有这个符号, 则解析到这一步, 则必须继续解析下去 (无论成功或失败), 其他选项不会被访问.

用下面的对比例子来理解:

```
# 不使用截断符号
percentage1
    =
    | '(' int '+' int ')' '/' int '%'  # 1. 当解析器解析到左括号时, 下一步没有找
                                       #    到 int, 则跳调到另一个选项解析.
    | int '/' int '%'  # 2. 跳到第二个选项重新解析.
    ;

# 使用截断符号
percentage2
    =
    | '(' ~ int '+' int ')' '/' int '%'  # 1. 当解析器解析到左括号时, 下一步没有
                                         #    找到 int, 则直接给出 failed 结果.
    | int '/' int '%'
    ;

```

## `s%{ e }*` or `s%{ e }+`

自然结合顺序.

```
s%{ e }+  # 捕获 'esesese' -> 生成 [e, s, e, s, e, s, e]
#                                      ^     ^     ^

# 简明示例:
'和'%{ /\w/ }+  # 捕获 '你和我和他' -> 生成 ['你', '和', '我', '和', '他']
#                                              e     s     e     s     e

# 其效果相当于
/\w/ { '和' ~ /\w/ }+  # 捕获 '你和我和他' -> 生成 ['你', '和', '我', '和', '他']
#                                                     e     s     e     s     e
```

PS#1: 如果百分号前的表达式比较复杂, 请使用捕获组形式 (小括号围住):

`(r s t ...)%{ e }*` or `(r s t ...)%{ e }+`

PS#2: 如果 `s%{ e }*` 捕获为空, 则得到的是空列表; 如果 `s%{ e }+` 捕获为空, 则 failed.

## `op<{ e }*` or `op<{ e }+`

向左结合的顺序. 与 `s%{ e }+` 的捕获效果相同, 但生成效果不同.

```
op<{ e }+  # 捕获 'esesese' -> (((e, s, e), s, e), s, e) -> (s, (s, (s, e, e), e), e)
#                              ||^-------^      |      |    |   |   ^-------^   |   |
#                              |^---------------^      |    |   ^---------------^   |
#                              ^-----------------------^    ^-----------------------^
#                              向左结合                  -> 将操作符前置, 表达式后置

'和'<{ /\w/ }+  # 捕获 '你和我和他' -> (('你', '和', '我'), '和', '他') -> 生成 ('和', ('和', '你', '我'), '他')
#                                          e     s     e      s     e              s      s     e     e      e
#                                      向左结合                         -> 将操作符前置, 表达式后置
```

## `op>{ e }*` or `op>{ e }+`

向右结合的顺序. 与 `s%{ e }+` 的捕获效果相同, 但生成效果不同.

```
op>{ e }+  # 捕获 'esesese' -> (e, s, (e, s, (e, s, e))) -> (s, (s, (s, e, e), e), e)
#                              |      |      ^-------^||    |   |   ^-------^   |   |
#                              |      ^---------------^|    |   ^---------------^   |
#                              ^-----------------------^    ^-----------------------^
#                              向右结合                  -> 将操作符前置, 表达式后置

'和'<{ /\w/ }+  # 捕获 '你和我和他' -> ('你', '和', ('我', '和', '他')) -> 生成 ('和', ('和', '我', '他'), '你')
#                                         e     s      e     s     e               s      s     e     e      e
#                                      向右结合                         -> 将操作符前置, 表达式后置
```

## `&e`

前瞻. 类似 re 里的前瞻.

## `!e`

后顾. 类似 re 里的后顾.



